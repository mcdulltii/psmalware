function encode ($string) {
  return [convert]::tobase64string([text.encoding]::unicode.GetBytes($string))
}

function decode ($string) {
  return [text.encoding]::unicode.getstring([convert]::frombase64string($string))
}

$decode = 'function decode ($string) {return [text.encoding]::unicode.getstring([convert]::frombase64string($string));};'

[System.Reflection.Assembly]::LoadWithPartialName("System.Security") | Out-Null
[System.Reflection.Assembly]::LoadWithPartialName("System.IO") | Out-Null

function en ()
{
  param(
    [Parameter(Mandatory = $true)] [byte[]]$bEn,
    [Parameter(Mandatory = $true)] [byte[]]$ps,
    [Parameter(Mandatory = $true)] [ref]$enB,
    [Parameter(Mandatory = $false)] [byte[]]$cSalt
  )
  [byte[]]$encB = @()
  # Salt must have at least 8 Bytes!!
  # Encrypt and decrypt must use the same salt
  # Define your own Salt here
  [byte[]]$aSaltBytes = @(4,7,12,254,123,98,34,12,67,12,122,111)
  if ($cSalt.Count -ge 1)
  {
    $aSaltBytes = $cSalt
  }
  [System.IO.MemoryStream]$oMemoryStream = New-Object System.IO.MemoryStream
  [System.Security.Cryptography.RijndaelManaged]$oAES = New-Object System.Security.Cryptography.RijndaelManaged
  $oAES.KeySize = 256;
  $oAES.BlockSize = 128;
  [System.Security.Cryptography.Rfc2898DeriveBytes]$oKey = New-Object System.Security.Cryptography.Rfc2898DeriveBytes ($ps,$aSaltBytes,1000);
  $oAES.Key = $oKey.GetBytes($oAES.KeySize / 8);
  $oAES.IV = $oKey.GetBytes($oAES.BlockSize / 8);
  $oAES.Mode = [System.Security.Cryptography.CipherMode]::CBC
  $oCryptoStream = New-Object System.Security.Cryptography.CryptoStream ($oMemoryStream,$oAES.CreateEncryptor(),[System.Security.Cryptography.CryptoStreamMode]::Write)
  try
  {
    $oCryptoStream.Write($bEn,0,$bEn.Length);
    $oCryptoStream.Close();
  }
  catch [Exception]
  {
    $enB.Value = [System.Text.Encoding]::ASCII.GetBytes("Error occured while encoding string. Salt or Password incorrect?")
    return $false
  }
  $oencB = $oMemoryStream.ToArray();
  $enB.Value = $oencB;
}

function gen-key {
  $rs = New-Object System.Random
  1..40 | ForEach-Object { $key += [char]$rs.next(97,122) }
  $kstring = [string]::Join("",($key))
  return $kstring
}

function obfuscate-base64 ($action,$key,$string) {

  $alpha = @{ "1" = "A";
    "2" = "B";
    "3" = "C";
    "4" = "D";
    "5" = "E";
    "6" = "F";
    "7" = "G";
    "8" = "H";
    "9" = "I";
    "10" = "J";
    "11" = "K";
    "12" = "L";
    "13" = "M";
    "14" = "N";
    "15" = "O";
    "16" = "P";
    "17" = "Q";
    "18" = "R";
    "19" = "S";
    "20" = "T";
    "21" = "U";
    "22" = "V";
    "23" = "W";
    "24" = "X";
    "25" = "Y";
    "26" = "Z";
  }

  $inv_alpha = @{}

  # create another hash table like alpha but with inverted values
  foreach ($l in $alpha.Keys) { $inv_alpha.Add($alpha[$l],$l) }

  $count = 0
  foreach ($ch in $string.GetEnumerator())
  {

    $c = [string]$ch
    if ($c -match "[a-zA-Z]")
    {

      $ival = $inv_alpha[$c]
      $s = $key[$count]

      if (!$s) { $count = 0; $s = $key[0] } # reset key to begining

      # juggling variable formats between integer and string methods
      $ss = [string]$s
      $S = $ss.ToUpper()
      $shift = $inv_alpha[$S]

      if ($action -match "hide")
      { $val = [int]$ival + [int]$shift }
      else { $val = [int]$ival - [int]$shift }

      if ([int]$val -lt "1") { $val = [int]$val + "26" }
      if ([int]$val -gt "26") { $val = [int]$val - "26" }

      # juggling variable formats between integer and string methods
      $sval = [string]$val
      $char = $alpha[$sval]
      $schar = [string]$char

      if ($c -cmatch "[a-z]")
      { $cipher = $schar.ToUpper(); $ncipher += [string]::Join("",($cipher)) }
      elseif ($c -cmatch "[A-Z]")
      { $cipher = $schar.ToLower(); $ncipher += [string]::Join("",($cipher)) }

      $count++

    } else { $ncipher += [string]::Join("",($c)) }

  }

  $scipher = [string]$ncipher
  return $scipher

}

function obfuscate-string ($action,$key,$b64o) {

  $b64n = obfuscate-base64 $action $key $b64o

  return $b64n

}
