function encode ($string) {
	return [convert]::tobase64string([text.encoding]::unicode.getbytes($string))
}

function decode ($string) {
	return [text.encoding]::unicode.getstring([convert]::frombase64string($string))
}

$decode = 'function decode ($string) {return [text.encoding]::unicode.getstring([convert]::frombase64string($string));};'

[System.reflection.assembly]::LoadWithPartialName("System.Security")|out-null
[System.reflection.assembly]::LoadWithPartialName("System.IO")|out-null

function en()
{
    Param(
        [Parameter(Mandatory=$true)][byte[]]$bEn,
        [Parameter(Mandatory=$true)][byte[]]$ps,
        [Parameter(Mandatory=$true)][ref]$enB,
        [Parameter(Mandatory=$false)][byte[]]$cSalt
    )		
    [byte[]] $encB = @()
    # Salt must have at least 8 Bytes!!
    # Encrypt and decrypt must use the same salt
    # Define your own Salt here
    [byte[]]$aSaltBytes = @(4,7,12,254,123,98,34,12,67,12,122,111) 
    if($cSalt.Count -ge 1)
    {
        $aSaltBytes=$cSalt
    }	
    [System.IO.MemoryStream] $oMemoryStream = new-object System.IO.MemoryStream
    [System.Security.Cryptography.RijndaelManaged] $oAES = new-object System.Security.Cryptography.RijndaelManaged
    $oAES.KeySize = 256;
    $oAES.BlockSize = 128;
    [System.Security.Cryptography.Rfc2898DeriveBytes] $oKey = new-object System.Security.Cryptography.Rfc2898DeriveBytes($ps, $aSaltBytes, 1000);
    $oAES.Key = $oKey.GetBytes($oAES.KeySize / 8);
    $oAES.IV = $oKey.GetBytes($oAES.BlockSize / 8);
    $oAES.Mode = [System.Security.Cryptography.CipherMode]::CBC
    $oCryptoStream = new-object System.Security.Cryptography.CryptoStream($oMemoryStream, $oAES.CreateEncryptor(), [System.Security.Cryptography.CryptoStreamMode]::Write)
    try
    {
        $oCryptoStream.Write($bEn, 0, $bEn.Length);
        $oCryptoStream.Close();
    }
    catch [Exception]
    {
        $enB.Value=[system.text.encoding]::ASCII.GetBytes("Error occured while encoding string. Salt or Password incorrect?")
        return $false
    }	
    $oencB = $oMemoryStream.ToArray();
    $enB.Value=$oencB;
}

function gen-key {
        $rs = New-Object System.Random
        1..40 | % { $key += [Char]$rs.next(97,122) }
        $kstring = [string]::join("", ($key))
        return $kstring
}

function obfuscate-base64( $action, $key, $string ) {

        $alpha = @{ "1" = "A";
                    "2" = "B";
                    "3" = "C";
                    "4" = "D";
                    "5" = "E";
                    "6" = "F";
                    "7" = "G";
                    "8" = "H";
                    "9" = "I";
                    "10" = "J";
                    "11" = "K";
                    "12" = "L";
                    "13" = "M";
                    "14" = "N";
                    "15" = "O";
                    "16" = "P";
                    "17" = "Q";
                    "18" = "R";
                    "19" = "S";
                    "20" = "T";
                    "21" = "U";
                    "22" = "V";
                    "23" = "W";
                    "24" = "X";
                    "25" = "Y";
                    "26" = "Z";
        }

        $inv_alpha = @{}

        # create another hash table like alpha but with inverted values
        foreach ($l in $alpha.Keys ) { $inv_alpha.add($alpha[$l],$l)}

        $count = 0
        foreach ($ch in $string.GetEnumerator())
        {

                $c = [string]$ch
                if ( $c -match "[a-zA-Z]")
                {

                        $ival = $inv_alpha[$c]
                        $s = $key[$count]

                        if (!$s) { $count = 0; $s = $key[0] }  # reset key to begining

                        # juggling variable formats between integer and string methods
                        $ss = [string]$s
                        $S = $ss.ToUpper()
                        $shift = $inv_alpha[$S]

                        if ($action -match "hide" )
                             { $val = [int]$ival + [int]$shift }
                        else { $val = [int]$ival - [int]$shift }

                        if ( [int]$val -lt "1"  ) { $val = [int]$val + "26" }
                        if ( [int]$val -gt "26" ) { $val = [int]$val - "26" }

                        # juggling variable formats between integer and string methods
                        $sval = [string]$val
                        $char = $alpha[$sval]
                        $schar = [string]$char

                        if ( $c -cmatch "[a-z]" )
                           { $cipher = $schar.ToUpper(); $ncipher += [string]::join("", ($cipher)) }
                        elseif ( $c -cmatch "[A-Z]" )
                           { $cipher = $schar.ToLower(); $ncipher += [string]::join("", ($cipher)) }

                        $count++

                } else { $ncipher += [string]::join("", ($c)) }

        }

        $scipher = [string]$ncipher
        return $scipher

}

function obfuscate-string( $action, $key, $b64o) {

    $b64n = obfuscate-base64 $action $key $b64o

    return $b64n

}
